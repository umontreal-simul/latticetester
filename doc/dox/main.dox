/**
 * 
 * \if NESTED_PROJECT
 * \page latticetester LatticeTester Guide
 * \else
 * \mainpage LatticeTester Guide
 * \endif
 * 
 * \section usr_guide User's guide
 * 
 * This is the user guide and API documentation of
 * [LatticeTester](https://github.com/umontreal-simul/latticetester),
 * a library intented to simplify the construction of software studying lattices.
 * *LatticeTester* is open source software distributed with a licence **X**
 * available on [Github](https://github.com/umontreal-simul/latticetester).
 *
 * \subsection usr_guide_ctn Content Outline
 * 
 * This page contains a summary description of the contents and the use case of
 * *LatticeTester*. The rest of the guide covers the following:
 * - \ref a_intro contains theory to get more familiar with lattices and the
 *   algorithms of *LatticeTester*
 * - \ref examples_page showcase the usage of *LatticeTester* to solve the
 *   problems above. It is a good starting point to start programming with
 *   the library right away.
 * - \ref usage presenting the installation process (the
 *   dependencies and the compilation process) and the usage of an executable
 *   bundled with *LatticeTester* to perform high-level use of the library.
 * - The full API documentation is also available in the **Namespaces** and
 *   **Classes** tabs.
 * 
 * The API documentation is automatically generated by
 * Doxygen.
 *
 * \section overview Overview
 * 
 * *LatticeTester* is a C++ library to perform various computations on
 * lattices \f$L_t\f$ in the \f$t\f$-dimensional rational space. Lattices are
 * discrete subgroups of a vector space (generally, the set of all integer
 * combinations of a basis of said vector space) encountered, as an example, in
 * the analysis of quasi-Monte Carlo point sets and certain kinds of
 * pseudo-random number generators.
 *
 * *LatticeTester* can perform most of its operations either on the **lattice**
 * spanned by \f$v_1, \ldots, v_s \in \mathbb{Q}^t\f$,
 * \f$L_t = \{\sum_{i=1}^s a_i v_i \ | \ a_i \in \mathbb{Z}\}\f$,
 * or its <b>m-dual lattice</b>,
 * \f$mL_t^* = \{w \ | \ w \cdot v \in m\mathbb{Z}, \ \forall v \in L_t\}\f$.
 * To do so, lattices are stored as a **basis**, a minimal (of cardinality \f$t\f$
 * set of generating
 * vectors \f$\{v_1, \ldots, v_t\} \in L_t\f$, rescalled to only have integer
 * coordinates. Vectors are stored as integer so that all the computations are
 * done exactly on the lattice. <b><i>LatticeTester</i> only accepts integer
 * lattices and
 * lattices need to be rescalled before being given as input.</b> Note that
 * \f$mL_t^*\f$ is also stored as integer vectors. In fact, \f$m\f$ is choosen
 * so that \f$L_t^* \subset \mathbb{Q}^t\f$ becomes \f$mL_t^* \subset\mathbb{Z}^t\f$.
 *
 * The main goal of this library is to implements and/or facilitate the
 * computation of theoretical measure of uniformity (or figures of merit) on
 * lattices, as it is the main concern when studying pseudo-random point sets
 * \cite rKNU81a\cite rNIE92b. To perform these algorithms efficiently,
 * *LatticeTester* also implements a handfull of handy lattices manipulations:
 * 1. **Lattice Basis Construction**: Given a set of vectors that are not
 * necessarily independent but span a lattice, find a basis for that lattice.
 * 2. **Dual Lattice Basis construction**: Given a lattice basis for \f$L_t\f$,
 * compute the corresponding m-dual lattice basis for \f$mL_t^*\f$ whether \f$m\f$
 * is known or not.
 * 3. **Lattice Basis Reduction**: Given a lattice basis, find another basis
 * whose vectors are nearly orthogonal or as short as possible.
 * There are many variants and definitions for this, such as the well known LLL
 * reduction which is available.
 * 4. **Shortest Vector computation**: Find the shortest non-zero vector in a
 * lattice, and prove it is the shortest.
 *
 * The measures of uniformity that are considered by this software are the
 * spectral test, that is the inverse length of the shortest vector in the
 * dual lattie, and the Beyer ratio, which is an old test (\cite rBEY71a)
 * inlcuded mainly as part of our legacy code base. Building on those mesures
 * of uniformity, *LatticeTester* also implements classes that help constructing
 * __figures of merit__. Figures of merit are a recurring theme in quasi-Monte
 * Carlo point set studies \cite vLEC12a. A figure of merit is a standardized
 * measure that can be used to compare point sets between them. Generally,
 * they are constructed as a weighted sum, or the minimum of weighted values : 
 * \f[
 *      \min_{i \subset I} \omega_i \ell_i
 * \f]
 * with \f$I\f$, a set of indices, \f$\omega_i\f$ being weights and \f$\ell_i\f$
 * a mesure on the projection of a lattice on set of indices \f$i\f$.
 *
 * Finaly, for the sake of convenience, *LatticeTester* also features a
 * high-level executable that can perform, without much flexibility, some of the
 * computations featured in *LatticeTester*. Its usage is described in \ref detailed_usage
 *
 * *LatticeTester* is not intended as a tool to search for lattices that conform
 * to certain prerequisites, but instead it can be extended with a few classes
 * to do so. <b>[LatNet Builder](https://github.com/umontreal-simul/latnetbuilder)</b>
 * and <b>[LatMRG](https://github.com/umontreal-simul/latmrg)</b> are software
 * tools designed in our laboratory that are examples of the capabilities of
 * this library. The first one is designed to analyze and search for lattice
 * rules for quasi-Monte-Carlo integration whilst the second does something similar
 * for linear congruential pseudo-random number generators.
 *
 * \subsection overview_type Types and representations
 *
 * Before diving into the features of *LatticeTester* lets look at what is NOT a
 * feature of this library, but is needed by it: the ability to manipulate
 * numbers with arbitrary size and precision with decent efficiency. To do that,
 * we use another
 * library called the Number Theory Library, more commonly called NTL. Anyone
 * using *LatticeTester* will need to use some of the functionnalities of NTL
 * at one point. Many basic mathematical functions require using this library
 * directly. Its documentation can be found at [https://www.shoup.net/ntl/](https://www.shoup.net/ntl/).
 * Note that *LatticeTester* also expands the NTL namespace. This extension
 * contains overloads of NTL functions to non-NTL types to ease the
 * usage of *LatticeTester* with NTL and non-NTL types in the same code.
 *
 * **Get back up to** \ref usr_guide_ctn
 *
 * */

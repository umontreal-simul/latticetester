// This file is part of LatticeTester.
//
// LatticeTester
// Copyright (C) 2012-2018  Pierre L'Ecuyer and Universite de Montreal
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef LATTICETESTER_RANK1LATTICE_H
#define LATTICETESTER_RANK1LATTICE_H

#include "latticetester/Util.h"
#include "latticetester/Const.h"
#include "latticetester/IntLattice.h"

namespace LatticeTester {

  /**
   * This class implements a general rank 1 lattice. A rank 1 lattice is the
   * lattice \f$\mathbb{Z}_m^d\f$ generated by a recurrence of the form
   * \f{equation}{
   *    u_i = (i \mathbf{a} \mod m),
   * \f}
   * where \f$\mathbf{a} \in \mathbb{Z}_m^d\f$.
   * It can also be seen as a lattice in \f$[0,1)^d\f$ by dividing the
   * coordinates of all the points by \f$m\f$. Given \f$\mathbf{a}\f$, the basis
   * of such a lattice is given, quite simply, by
   * \f{align*}{
   *    \mathbf{v}_1 & = a \\
   *    \mathbf{v}_2 & = m \mathbf{e}_2 \\
   *    \vdots & \\
   *    \mathbf{v}_d & = m \mathbf{e}_v \\
   * \f}
   * where \f$\mathbf{e}_i\f$ is a vector of 0 with a 1 at the \f$i^\text{th}\f$
   * coordinate.
   * 
   * A condition that is most wanted when building a rank 1 lattice is that 
   * \f$\gcd(a_i, m) = 1,\ \forall 1\leq i \leq d\f$. If this condition is
   * verified, the lattice covers the same number of points, \f$m\f$, in all its
   * projections. Note that if one searches for such a lattice, it is possible,
   * without loss of generality generality, to assume that \f$a_1 = 1\f$.
   *
   * This class implements or reuses the methods of IntLattice, as well as some
   * new methods to build a basis from a generator.
   */
  template<typename Int, typename BasInt, typename Dbl, typename RedDbl>
    class Rank1Lattice: public IntLattice<Int, BasInt, Dbl, RedDbl> {

      private:
        typedef NTL::vector<Int> IntVec;
        typedef NTL::vector<BasInt> BasIntVec;
        typedef NTL::matrix<BasInt> BasIntMat;
        typedef NTL::vector<Dbl> DblVec;

      public:

        /**
         * Full constructor. The lattice can be completely described by the
         * generating vector `a`, the dimension `maxDim`, and the modulo `m`
         * since all the points of the lattice can be obtained by taking 
         * \f[
         *      u_i = (i \mathbf{a} \mod m),
         * \f]
         * with \f$\mathbf{a}\f$ being an assortment of the first components of
         * `a` (`a` being a vector of dimension `maxDim`).
         *
         * This initializes all needed internal components (see `IntLattice`).
         * In particular, this sets maximal dimension for this object to
         * `maxDim`. This means that when creating an object of this class, it
         * is important that \f$\text{maxDim} \leq \dim(a)\f$ and ideal that
         * the equality holds. This constructor does not build the basis to
         * allow for more flexibility in the dimension when doing so.
         */
        Rank1Lattice (const Int & m, const IntVec & a, int maxDim,
            LatticeTester::NormType norm = LatticeTester::L2NORM);

        /**
         * Copy constructor.
         */
        Rank1Lattice (const Rank1Lattice<Int, BasInt, Dbl, RedDbl> & Lat);

        /**
         * Assigns `Lat` to this object.
        */
        Rank1Lattice & operator= (const Rank1Lattice<Int, BasInt, Dbl, RedDbl>
            & Lat);

        /**
         * Destructor.
         */
        ~Rank1Lattice();

        /**
         * Returns the firsts components of the vector of multipliers \f$a\f$ as
         * a string. This will print only the a number of components of `a`
         * corresponding to the current dimension of the lattice.
         */
        std::string toStringCoef() const;

        /**
         * Builds the basis in dimension `d`. `d` has to be smaller or equal
         * than `this->maxDim()`
         */
        void buildBasis (long d);

        /**
         * Dualize the matrix. The matrix entered need to have
         * the particular shape describe ERWAN
         */
        void dualize ();

        /**
         * Increases the dimension by 1.
         */
        void incDim ();

      protected:

        /**
         * Initializes the rank 1 lattice.
         */
        void init();

        /**
         * The multipliers of the rank 1 lattice rule.
         */
        IntVec m_a;
    };

  //============================================================================

  template<typename Int, typename BasInt, typename Dbl, typename RedDbl>
    Rank1Lattice<Int, BasInt, Dbl, RedDbl>::Rank1Lattice (
        const Int & m, const IntVec & a, int maxDim, NormType norm):
      IntLattice<Int, BasInt, Dbl, RedDbl> (m, 1, maxDim, true, norm)
  {
    this->m_a = a;
    init();
  }

  //============================================================================

  template<typename Int, typename BasInt, typename Dbl, typename RedDbl>
    Rank1Lattice<Int, BasInt, Dbl, RedDbl>::~Rank1Lattice()
    {
      this->m_a.clear ();
    }

  //============================================================================

  template<typename Int, typename BasInt, typename Dbl, typename RedDbl>
    void Rank1Lattice<Int, BasInt, Dbl, RedDbl>::init()
    {
      IntLattice<Int, BasInt, Dbl, RedDbl>::init();
      for (int r = 1; r < this->getDim(); r++)
        this->m_lgVolDual2[r] = this->m_lgVolDual2[r - 1];
    }

  //============================================================================

  template<typename Int, typename BasInt, typename Dbl, typename RedDbl>
    Rank1Lattice<Int, BasInt, Dbl, RedDbl> &
    Rank1Lattice<Int, BasInt, Dbl, RedDbl>::operator= (
        const Rank1Lattice<Int, BasInt, Dbl, RedDbl> & lat)
    {
      if (this == &lat)
        return * this;
      this->copy (lat);
      init ();
      this->m_a = lat.m_a;
      return *this;
    }

  //============================================================================

  template<typename Int, typename BasInt, typename Dbl, typename RedDbl>
    Rank1Lattice<Int, BasInt, Dbl, RedDbl>::Rank1Lattice (
        const Rank1Lattice<Int, BasInt, Dbl, RedDbl> & lat): 
      IntLattice<Int, BasInt, Dbl, RedDbl> (
          lat.m_modulo, lat.getOrder (), lat.getDim (), lat.getNorm ())
  {
    // MyExit (1, "Rank1Lattice:: constructeur n'est pas terminé " );
    init ();
    this->m_a = lat.m_a;
  }

  //============================================================================

  template<typename Int, typename BasInt, typename Dbl, typename RedDbl>
    std::string Rank1Lattice<Int, BasInt, Dbl, RedDbl>::toStringCoef ()const
    {
      return toString (this->m_a, 0, this->getDim ());
    }

  //============================================================================

  template<typename Int, typename BasInt, typename Dbl, typename RedDbl>
    void Rank1Lattice<Int, BasInt, Dbl, RedDbl>::incDim ()
    {
      assert(1 + this->getDim() <= this->m_maxDim);
      buildBasis (1 + this->getDim ());
      this->setNegativeNorm ();
      this->setDualNegativeNorm ();
    }

  //============================================================================

  template<typename Int, typename BasInt, typename Dbl, typename RedDbl>
    void Rank1Lattice<Int, BasInt, Dbl,RedDbl>::buildBasis (long d)
    {
      assert(d <= this->m_maxDim);
      this->setDim (d);
      this->m_basis.SetDims(d,d);
      this->m_dualbasis.SetDims(d,d);

      // conv(m_v[1][1], 1);

      for (int j = 0; j < d; j++) {
        this->m_basis (0, j) = this->m_a[j];
      }

      for (int i = 1; i < d; i++) {
        for (int j = 0; j < d; j++) {
          if (i == j) {
            this->m_basis (i, j) = this->m_modulo;
          } else {
            this->m_basis (i, j) = 0;
          }
        }
      }

      // if a[0] != 1, the basis must be triangularized
      //BasisConstruction<BasInt> constr;
      if (this->m_basis (0, 0) != 1) {
        //constr.GCDConstruction(this->m_basis);
         Triangularization (
             this->m_basis, this->m_dualbasis, d, d, this->m_modulo);
         dualize ();
      }
      //constr.DualConstruction(this->m_basis, this->m_dualbasis, this->m_modulo);
      CalcDual (this->m_basis, this->m_dualbasis, d, this->m_modulo);
      this->setNegativeNorm ();
      this->setDualNegativeNorm ();
    }

  //============================================================================

  template<typename Int, typename BasInt, typename Dbl, typename RedDbl>
    void Rank1Lattice<Int, BasInt, Dbl, RedDbl>::dualize ()
    {
      BasIntMat tmps(this->m_basis);
      this->m_basis = this->m_dualbasis;
      this->m_dualbasis = tmps;
    }

  extern template class Rank1Lattice<std::int64_t, std::int64_t, double, double>;
  extern template class Rank1Lattice<NTL::ZZ, NTL::ZZ, double, double>;
  extern template class Rank1Lattice<NTL::ZZ, NTL::ZZ, NTL::RR, NTL::RR>;

} // End namespace LatticeTester

#endif
